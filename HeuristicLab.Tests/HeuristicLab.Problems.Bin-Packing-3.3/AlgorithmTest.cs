using System;
using System.IO;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using HeuristicLab.Problems.BinPacking3D;
using System.Collections.Generic;
using System.Linq;
using HeuristicLab.Core;

namespace HeuristicLab.Problems.BinPacking.Tests {
  [TestClass]
  public class AlgorithmTest {

    private struct Dimension {
      public int Id { get; set; }
      public int Width { get; set; }
      public int Height { get; set; }
      public int Depth { get; set; }
    }

    #region TestRandomInstanceProvider


    /// <summary>
    /// Tests if the generated random instance equals to the references generated by david pisinger 
    /// http://www.diku.dk/~pisinger/new3dbpp/test3dbpp.c
    /// </summary>
    [TestMethod]
    [TestCategory("Problems.BinPacking")]
    public void TestRandomInstanceProvider() {
      
      var referenceItemLists = ReadReferenceItemLists();
      TestRandomInstanceProviderByClass(new RandomInstanceClass1ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass2ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass3ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass4ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass5ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass6ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass7ProviderWithSRand(), referenceItemLists);
      TestRandomInstanceProviderByClass(new RandomInstanceClass8ProviderWithSRand(), referenceItemLists);
      
    }

    private IDictionary<string, List<Dimension>> ReadReferenceItemLists() {
      var itemList = new Dictionary<string, List<Dimension>>();
      string path = @"C:\HEAL\BinPacking\Algorithm\export";//todo which location can be used for storing the reference files? At the moment their location can be found on the local disc

      string[] files = Directory.GetFiles(path);
      foreach (string filePath in files) {
        string key = Path.GetFileNameWithoutExtension(filePath);

        using (StreamReader reader = new StreamReader(filePath)) {
          int lineNumber = 1;
          List<Dimension> dimensionList = new List<Dimension>();
          while (!reader.EndOfStream) {
            string line = reader.ReadLine();
            if (lineNumber > 2) {
              string[] lineValues = line.Split('\t');
              int id;
              int depth;
              int width;
              int height;
              Int32.TryParse(lineValues[0], out id);
              Int32.TryParse(lineValues[1], out depth);
              Int32.TryParse(lineValues[2], out width);
              Int32.TryParse(lineValues[3], out height);
              dimensionList.Add(new Dimension() {
                Id = id,
                Depth = depth,
                Width = width,
                Height = height
              });
            }
            lineNumber++;
          }
          itemList.Add(key, dimensionList);
        }
      }
      return itemList;
    }

    private void TestRandomInstanceProviderByClass(RandomInstanceProviderWithSRand randomInstanceProvider, IDictionary<string, List<Dimension>> referenceItems) {

      var dataDescriptors = randomInstanceProvider.GetDataDescriptors();
      foreach (var dataDescriptor in dataDescriptors) {
        List<Dimension> testItemDimensions = null;
        if (referenceItems.TryGetValue(dataDescriptor.Name, out testItemDimensions)) {
          var packingItems = randomInstanceProvider.LoadData(dataDescriptor).Items;
          Assert.IsNotNull(packingItems);
          Assert.AreEqual(testItemDimensions.Count, packingItems.Length);
          for (int i = 0; i < packingItems.Length; i++) {
            Assert.AreEqual(testItemDimensions[i].Width, packingItems[i].Width);
            Assert.AreEqual(testItemDimensions[i].Height, packingItems[i].Height);
            Assert.AreEqual(testItemDimensions[i].Depth, packingItems[i].Depth);
          }
        }
      }
    }
    #endregion

    #region TestExtremePointAlgorithm

    /// <summary>
    /// Constants for testing the algorithm
    /// The test parameter are defined in the paper 
    /// </summary>
    private const int NUMBER_OF_TEST_INSTANCES = 10;
    private static readonly int[] TEST_CLASSES = { 1, 2 };
    private static readonly int[] NUMBER_OF_TEST_ITEMS = { 50, 100, 150, 200 };

    [TestMethod]
    [TestCategory("Problems.BinPacking")]
    public void TestExtremePointAlgorithm() {
      TestExtremePointAlgorithmByParameters(new RandomInstanceClass1ProviderWithSRand(), 1, SortingMethod.Given, FittingMethod.FirstFit);


    }

    private void TestExtremePointAlgorithmByParameters(RandomInstanceProviderWithSRand randomInstanceProvider, int @class, SortingMethod sortingMethod, FittingMethod fittingMethod) {
      var dataDescriptors = randomInstanceProvider.GetDataDescriptors();
      var referenceValues = GetReferenceAlgorithmValues();
      foreach (var numItems in NUMBER_OF_TEST_ITEMS) {
        int sumNumberOfBins = 0;
        for (int instance = 1; instance <= NUMBER_OF_TEST_INSTANCES; instance++) {
          string name = string.Format("n={0}-id={1:00} (class={2})", numItems, instance, @class);
          var selectedDataDescriptor = dataDescriptors.Where(dataDescriptor => dataDescriptor.Name == name);
          Assert.IsNotNull(selectedDataDescriptor?.First());
          var packingData = randomInstanceProvider.LoadData(selectedDataDescriptor.First());

          ExtremePointAlgorithm algorithm = new ExtremePointAlgorithm();
          algorithm.SortingMethodParameter.Value.Value = sortingMethod;
          algorithm.FittingMethodParameter.Value.Value = fittingMethod;
          algorithm.Problem.Load(packingData);

          algorithm.Start();

          PackingPlan<BinPacking3D.PackingPosition, PackingShape, PackingItem> bestPackingPlan = null;
          foreach (Optimization.IResult result in algorithm.Results) {
            if (result.Name == "Best Solution") {
              bestPackingPlan = (PackingPlan<BinPacking3D.PackingPosition, PackingShape, PackingItem>)result.Value;
              break;
            }
          }

          sumNumberOfBins += bestPackingPlan.NrOfBins;
        }

        double referenceValue = 0.0;
        
        if (referenceValues.TryGetValue(new Tuple<int, int, SortingMethod>(@class, numItems, sortingMethod), out referenceValue)) {
          Console.WriteLine($"{numItems}: {referenceValue} {(double)sumNumberOfBins / (double)NUMBER_OF_TEST_INSTANCES}");
          Assert.AreEqual(referenceValue, (double)sumNumberOfBins / (double)NUMBER_OF_TEST_INSTANCES, 1.0);
        }
      }
    }


    /// <summary>
    /// Returns a dictionary which contains the reference values from table 2 given by the paper https://www.cirrelt.ca/DocumentsTravail/CIRRELT-2007-41.pdf 
    /// </summary>
    /// <returns></returns>
    private Dictionary<Tuple<int, int, SortingMethod>, double> GetReferenceAlgorithmValues() {
      Dictionary<Tuple<int, int, SortingMethod>, double> referenceValues = new Dictionary<Tuple<int, int, SortingMethod>, double>();

      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 50, SortingMethod.Given), 14.6);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 100, SortingMethod.Given), 29.2);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 150, SortingMethod.Given), 40.1);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 200, SortingMethod.Given), 55.9);

      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 50, SortingMethod.HeightVolume), 15);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 100, SortingMethod.HeightVolume), 29.2);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 150, SortingMethod.HeightVolume), 39.9);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 200, SortingMethod.HeightVolume), 55.6);

      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 50, SortingMethod.VolumeHeight), 14.4);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 100, SortingMethod.VolumeHeight), 29.5);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 150, SortingMethod.VolumeHeight), 40.3);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 200, SortingMethod.VolumeHeight), 55.7);

      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 50, SortingMethod.AreaHeight), 14.4);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 100, SortingMethod.AreaHeight), 28.3);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 150, SortingMethod.AreaHeight), 39.2);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 200, SortingMethod.AreaHeight), 53.2);

      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 50, SortingMethod.HeightArea), 15);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 100, SortingMethod.HeightArea), 29);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 150, SortingMethod.HeightArea), 39.8);
      referenceValues.Add(new Tuple<int, int, SortingMethod>(1, 200, SortingMethod.HeightArea), 55.1);


      var s = referenceValues[new Tuple<int, int, SortingMethod>(1, 200, SortingMethod.HeightArea)];

      return referenceValues;
    }


    #endregion
  }

}
